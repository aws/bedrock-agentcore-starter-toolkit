# serializer version: 1
# name: test_cdk_snapshots[scenario_0][scenario_0-Strands-custom auth; stm+ltm memory; custom headers]
  dict({
    '.bedrock_agentcore.yaml': '''
      default_agent: bootstrap_agent
      is_agentcore_bootstrap_project: true
      agents:
        bootstrap_agent:
          name: bootstrap_agent
          entrypoint: <PROJECT_ROOT>/src
          deployment_type: container
          aws:
            region: null
          bedrock_agentcore:
            agent_id: null
            agent_arn: null
            agent_session_id: null
  
    ''',
    'README.md': '''
      This is a monorepo generated by the agentcore bootstrap CLI tool!
      
      # Deploying
      
      If you want to skip the explanation of the `src/` directory and deploy straight away, see the below terraform/ section.
      
      # Layout
      
      There are three main directories created in this project: `src`, `mcp`, and `terraform`. In a monorepo setup all of the code—source, test, and IaC for deployment—is contained in one repository. Everything needed to
      define runtime code and deploy it into your AWS account is contained in this project.
      
      The `terraform` directory models all of the Bedrock AgentCore and related resources. There are direct references between `terraform` and the runtime `src/`. For example, the IaC code expects to find the
      Dockerfile at a specific relative path.
      
      ## src/
      
      The `src/` directory is where you will find the runtime code.
      
      Start with main entrypoint to the generated app, `src/main.py`. This file defines an agent using Strands and defines an entrypoint method with the Bedrock AgentCore SDK:
      
      ```
      @app.entrypoint
      def invoke(payload):
          # assume payload input is structured as { "prompt": "<user input>" }
      ```
      
      Next there is the `src/mcp_client` directory. Here you will find `client.py`. This file defines an MCP client from the chosen Strands library. That client points to the
      gateway URL for the AgentCore gateway that is modeled in the `terraform` directory. Behind that gateway is a custom MCP tool modeled as a Lambda function (see below `mcp/` section for more details).
      The authorizer for the gateway is the custom authorizer that was passed in `.bedrock_agentcore.yaml`. The `_get_access_token()` method needs to be implemented
      to successfully obtain JWT tokens from your custom authorizer.
      
      ## mcp/
      
      The `mcp/` directory defines a simple Python tool that meets the MCP specification called `placeholder_tool`. The specification for the tool's inputs is defined in the inline schema in the modeled
      `terraform` directory. When replacing the dummy implementation in `mcp/lambda/handler.py`, make sure to update the corresponding Lambda target schema to reflect the changes before re-deploying.
      The `placeholder_tool` implementation demonstrates the tool name and input payload conventions of a Lambda behind the gateway. The gateway supports [flexible target types](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-add-target-api.html).
      
      ## terraform/
      
      This directory contains a Terraform project that models AgentCore and related AWS resources.
      
      First check that the `terraform` binary is installed with version >= 1.2:
      - `terraform version -json | jq -r '.terraform_version'`
      - Terraform install [webpage](https://developer.hashicorp.com/terraform/install)
      
      - shorthand: `cd terraform && terraform init && terraform apply`
      - navigate to the `terraform` directory: `cd terraform`
      - download dependencies: `terraform init`
      - [optional] overview resources to be deployed: `terraform plan`
      - deploy to AWS: `terraform apply`
      
      # `agentcore bootstrap` output
      
      Primarily, `agentcore bootstrap` outputs the directory that this `README.md` file is contained in. Nothing is deployed into AWS automatically.
      Execute the appropriate deployment commands in the `terraform` directory to deploy.
      
      There is also a `.bedrock_agentcore.yaml` file output in the `testProj` directory. This file contains a minimal definition with your agent name when it is created. After deploying the project, when running
      `agentcore invoke` or `agentcore status`, the command updates `.bedrock_agentcore.yaml` with the ID and ARN of your runtime so the CLI can successfully call the runtime using boto3.
      
      # Invoking the deployed Runtime
      
      The two easiest ways to invoke your runtime after deploying:
      
      1. `agentcore invoke`
         Example:
         ```
         agentcore invoke '{"prompt": "what can you do?"}'
         ```
      
      2. Navigate to the “Test Console” page in the Bedrock AgentCore AWS console. Select your runtime and the `DEFAULT` version. Provide an input.
         Example:
         ```
         {"prompt": "what can you do?"}
         ```
    ''',
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              → e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/.dockerignore': '''
      # Build artifacts
      build/
      dist/
      *.egg-info/
      *.egg
      
      # Python cache
      __pycache__/
      __pycache__*
      *.py[cod]
      *$py.class
      *.so
      .Python
      
      # Virtual environments
      .venv/
      .env
      venv/
      env/
      ENV/
      
      # Testing
      .pytest_cache/
      .coverage
      .coverage*
      htmlcov/
      .tox/
      *.cover
      .hypothesis/
      .mypy_cache/
      .ruff_cache/
      
      # Development
      *.log
      *.bak
      *.swp
      *.swo
      *~
      .DS_Store
      
      # IDEs
      .vscode/
      .idea/
      
      # Version control
      .git/
      .gitignore
      .gitattributes
      
      # Documentation
      docs/
      
      # CI/CD
      .github/
      .gitlab-ci.yml
      .travis.yml
      
      # Project specific
      tests/
      
      # Bedrock AgentCore specific - keep config but exclude runtime files
      .bedrock_agentcore.yaml
      .dockerignore
      .bedrock_agentcore/
      
      # Keep wheelhouse for offline installations
      # wheelhouse/
      
      # Monorepo directories
      cdk/
      terraform/
  
    ''',
    'src/Dockerfile': '''
      FROM ghcr.io/astral-sh/uv:python3.10-bookworm-slim
      WORKDIR /app
      
      # All environment variables in one layer
      ENV UV_SYSTEM_PYTHON=1 \
          UV_COMPILE_BYTECODE=1 \
          UV_NO_PROGRESS=1 \
          PYTHONUNBUFFERED=1 \
          DOCKER_CONTAINER=1
      
      
      
      COPY pyproject.toml pyproject.toml
      # Install from requirements file
      RUN uv pip install -r pyproject.toml
      
      
      
      
      RUN uv pip install aws-opentelemetry-distro>=0.10.1
      
      
      # Signal that this is running in Docker for host binding logic
      ENV DOCKER_CONTAINER=1
      
      # Create non-root user
      RUN useradd -m -u 1000 bedrock_agentcore
      USER bedrock_agentcore
      
      EXPOSE 9000
      EXPOSE 8000
      EXPOSE 8080
      
      # Copy entire project (respecting .dockerignore)
      COPY . .
      
      # Use the full module path
      
      CMD ["opentelemetry-instrument", "python", "-m", "main"]
  
    ''',
    'src/main.py': '''
      from strands import Agent, tool
      from bedrock_agentcore import BedrockAgentCoreApp
      from mcp_client.client import get_streamable_http_mcp_client
      
      # Import AgentCore Gateway as Streamable HTTP MCP Client
      mcp_client = get_streamable_http_mcp_client()
      
      # Define a simple function tool
      @tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      
      @app.entrypoint
      def invoke(payload):
          # assume payload input is structured as { "prompt": "<user input>" }
      
          # Create an Agent with MCP tools
          with mcp_client:
              # Create an Agent with MCP tools
              tools = mcp_client.list_tools_sync()
              agent = Agent(tools=tools + [add_numbers])
      
              # Process the user prompt
              prompt = payload.get("prompt", "What is Agentic AI?")
      
              # Run the agent
              response = agent(prompt)
      
              # Return result
              return {
                  "response": response
              }
      
      if __name__ == "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from mcp.client.streamable_http import streamablehttp_client
      from strands.tools.mcp.mcp_client import MCPClient
      
      def _get_access_token():
          """
          Stub implementation if using a custom authorizer.
          """
          raise NotImplementedError("Custom authorizer flow is not implemented.")
      
      
      def get_streamable_http_mcp_client() -> MCPClient:
          """
          Returns an MCP Client for AgentCore Gateway compatible with Strands
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MCPClient(lambda: streamablehttp_client(gateway_url, headers={"Authorization": f"Bearer {access_token}"}))
    ''',
    'src/pyproject.toml': '''
      [build-system]
      requires = ["setuptools>=68", "wheel"]
      build-backend = "setuptools.build_meta"
      
      [project]
      name = "testProj"
      version = "0.1.0"
      requires-python = ">=3.10"
      
      dependencies = [
          "bedrock-agentcore >= 1.0.3",
          "mcp >= 1.19.0",
          "requests >= 2.32.5",
          "strands-agents >= 1.13.0"
      ]
    ''',
    'terraform': None,
    'terraform/bedrock_agentcore.tf': '''
      ################################################################################
      # ECR Repository
      ################################################################################
      resource "aws_ecr_repository" "agentcore_terraform_runtime" {
        name                 = "bedrock-agentcore/${lower(var.app_name)}"
        image_tag_mutability = "MUTABLE"
      
        image_scanning_configuration {
          scan_on_push = true
        }
      
        encryption_configuration {
          encryption_type = "KMS"
        }
      }
      
      data "aws_ecr_authorization_token" "token" {}
      
      locals {
        src_files = fileset("../${path.root}/src", "**")
        src_hashes = [
          for f in local.src_files :
          filesha256("../${path.root}/src/${f}")
        ]
      
        # Collapse all file hashes into one
        src_hash = sha256(join("", local.src_hashes))
      }
      
      resource "null_resource" "docker_image" {
        depends_on = [aws_ecr_repository.agentcore_terraform_runtime]
      
        triggers = {
          src_hash = local.src_hash
        }
      
        provisioner "local-exec" {
          interpreter = ["/bin/bash", "-c"]
          command     = <<EOF
            source ~/.bash_profile || source ~/.profile || true
      
            if ! command -v docker &> /dev/null; then
              echo "Docker is not installed or not in PATH. Please install Docker and try again."
              exit 1
            fi
      
            aws ecr get-login-password | docker login --username AWS --password-stdin ${data.aws_ecr_authorization_token.token.proxy_endpoint}
      
            docker build -t ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest ../${path.root}/src
      
            docker push ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest
          EOF
        }
      }
      
      
      ################################################################################
      # MCP Lambda Function
      ################################################################################
      data "archive_file" "mcp_lambda_zip" {
        type        = "zip"
        source_dir  = "../${path.root}/mcp/lambda"
        output_path = "../${path.root}/mcp_lambda.zip"
      }
      
      resource "aws_lambda_function" "mcp_lambda" {
        function_name = "${var.app_name}-McpLambda"
        role          = aws_iam_role.mcp_lambda_role.arn
        handler       = "handler.lambda_handler"
        runtime       = "python3.12"
      
        filename         = data.archive_file.mcp_lambda_zip.output_path
        source_code_hash = data.archive_file.mcp_lambda_zip.output_base64sha256
      }
      
      resource "aws_iam_role" "mcp_lambda_role" {
        name = "${var.app_name}-McpLambdaRole"
      
        assume_role_policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action = "sts:AssumeRole"
            Effect = "Allow"
            Principal = {
              Service = "lambda.amazonaws.com"
            }
          }]
        })
      }
      
      resource "aws_iam_role_policy_attachment" "mcp_lambda_basic" {
        role       = aws_iam_role.mcp_lambda_role.name
        policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      }
      
      ################################################################################
      # AgentCore Gateway Roles
      ################################################################################
      
      resource "aws_iam_role" "agentcore_gateway_role" {
        name               = "${var.app_name}-AgentCoreGatewayRole"
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      resource "aws_iam_role_policy_attachment" "agentcore_gateway_permissions" {
        role       = aws_iam_role.agentcore_gateway_role.name
        policy_arn = "arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess"
      }
      
      resource "aws_iam_role_policy" "agentcore_gateway_lambda_invoke" {
        role = aws_iam_role.agentcore_gateway_role.id
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action   = ["lambda:InvokeFunction"]
            Effect   = "Allow"
            Resource = [aws_lambda_function.mcp_lambda.arn]
          }]
        })
      }
      
      ################################################################################
      # AgentCore Gateway
      ################################################################################
      
      resource "aws_bedrockagentcore_gateway" "agentcore_gateway" {
        name            = "${var.app_name}-AgentCoreGateway"
        protocol_type   = "MCP"
        role_arn        = aws_iam_role.agentcore_gateway_role.arn
        authorizer_type = "CUSTOM_JWT"
        authorizer_configuration {
          custom_jwt_authorizer {
            discovery_url   = "https://aws.dev"
            allowed_clients = [
              
              "12345", 
              
              "6789"
              
            ]
          }
        }
      }
      
      resource "aws_bedrockagentcore_gateway_target" "agentcore_gateway_lambda_target" {
        name               = "${var.app_name}-AgentCoreGatewayTarget"
        gateway_identifier = aws_bedrockagentcore_gateway.agentcore_gateway.gateway_id
      
        credential_provider_configuration {
          gateway_iam_role {}
        }
      
        target_configuration {
          mcp {
            lambda {
              lambda_arn = aws_lambda_function.mcp_lambda.arn
      
              tool_schema {
                inline_payload {
                  name        = "placeholder_tool"
                  description = "Placeholder tool (no-op)."
                  input_schema {
                    type        = "object"
                    description = "Example input schema for placeholder tool"
                    property {
                      name        = "string_param"
                      type        = "string"
                      description = "Example string parameter."
                    }
                    property {
                      name        = "int_param"
                      type        = "integer"
                      description = "Example integer parameter."
                    }
                    property {
                      name        = "float_array_param"
                      type        = "array"
                      description = "Example float array parameter."
                      items {
                        type = "number"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime IAM Roles
      ################################################################################
      
      data "aws_iam_policy_document" "bedrock_agentcore_assume_role" {
        statement {
          effect  = "Allow"
          actions = ["sts:AssumeRole"]
          principals {
            type        = "Service"
            identifiers = ["bedrock-agentcore.amazonaws.com"]
          }
        }
      }
      
      resource "aws_iam_role" "agentcore_runtime_execution_role" {
        name        = "${var.app_name}-AgentCoreRuntimeRole"
        description = "Execution role for Bedrock AgentCore Runtime"
      
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html#runtime-permissions-execution
      resource "aws_iam_role_policy" "agentcore_runtime_execution_role_policy" {
        role   = aws_iam_role.agentcore_runtime_execution_role.id
        name = "${var.app_name}-AgentCoreRuntimeExecutionPolicy"
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "ECRImageAccess"
              Effect = "Allow"
              Action = [
                "ecr:BatchGetImage",
                "ecr:GetDownloadUrlForLayer",
              ]
              Resource = [
                "arn:aws:ecr:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:repository/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogStreams",
                "logs:CreateLogGroup",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogGroups",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:CreateLogStream",
                "logs:PutLogEvents",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*",
              ]
            },
            {
              Sid    = "ECRTokenAccess"
              Effect = "Allow"
              Action = [
                "ecr:GetAuthorizationToken",
              ]
              Resource = "*"
            },
            {
              Effect = "Allow"
              Action = [
                "xray:PutTraceSegments",
                "xray:PutTelemetryRecords",
                "xray:GetSamplingRules",
                "xray:GetSamplingTargets",
              ]
              Resource = [
                "*",
              ]
            },
            {
              Effect   = "Allow"
              Resource = "*"
              Action   = "cloudwatch:PutMetricData"
              Condition = {
                StringEquals = {
                  "cloudwatch:namespace" = "bedrock-agentcore"
                }
              }
            },
            {
              Sid    = "GetAgentAccessToken"
              Effect = "Allow"
              Action = [
                "bedrock-agentcore:GetWorkloadAccessToken",
                "bedrock-agentcore:GetWorkloadAccessTokenForJWT",
                "bedrock-agentcore:GetWorkloadAccessTokenForUserId",
              ]
              Resource = [
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default",
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default/workload-identity/agentName-*",
              ]
            },
            {
              Sid    = "BedrockModelInvocation"
              Effect = "Allow"
              Action = [
                "bedrock:InvokeModel",
                "bedrock:InvokeModelWithResponseStream",
              ]
              Resource = [
                "arn:aws:bedrock:*::foundation-model/*",
                "arn:aws:bedrock:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:*",
              ]
            },
          ]
        })
      }
      
      
      ################################################################################
      # AgentCore Memory
      ################################################################################
      resource "aws_bedrockagentcore_memory" "agentcore_memory" {
        name                  = "bootstrap_agent_memory"
        description           = "Memory resource with 30 days event expiry"
        event_expiry_duration = 30
      }
      # Long Term Memory Configuration
      resource "aws_bedrockagentcore_memory_strategy" "user_preference_memory_strategy" {
        memory_id  = aws_bedrockagentcore_memory.agentcore_memory.id
        name       = "UserPreferences"
        namespaces = ["/users/{actorId}/preferences"]
        type       = "USER_PREFERENCE"
      }
      
      resource "aws_bedrockagentcore_memory_strategy" "semantic_memory_strategy" {
        memory_id  = aws_bedrockagentcore_memory.agentcore_memory.id
        name       = "SemanticFacts"
        namespaces = ["/users/{actorId}/facts"]
        type       = "SEMANTIC"
      }
      
      resource "aws_bedrockagentcore_memory_strategy" "summary_memory_strategy" {
        memory_id  = aws_bedrockagentcore_memory.agentcore_memory.id
        name       = "SessionSummaries"
        namespaces = ["/summaries/{actorId}/{sessionId}"]
        type       = "SUMMARIZATION"
      }
      
      ################################################################################
      # AgentCore Runtime
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime" "agentcore_runtime" {
        agent_runtime_name = "bootstrap_agent"
        role_arn           = aws_iam_role.agentcore_runtime_execution_role.arn
      
        agent_runtime_artifact {
          container_configuration {
            container_uri = "${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest"
          }
        }
      
        depends_on = [null_resource.docker_image, aws_bedrockagentcore_memory.agentcore_memory]
      
        network_configuration {
          network_mode = "PUBLIC"
        }
        request_header_configuration {
          request_header_allowlist = ["x-amzn-bedrock", "x-amzn-agentcore"]
        }
        environment_variables = {
          MEMORY_ID = aws_bedrockagentcore_memory.agentcore_memory.id
          GATEWAY_URL = aws_bedrockagentcore_gateway.agentcore_gateway.gateway_url
        }
        authorizer_configuration {
          custom_jwt_authorizer {
            discovery_url    = "https://aws.dev"
            allowed_clients  = ["12345", "6789"]
          }
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime Endpoints
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "dev_endpoint" {
        name             = "DEV"
        agent_runtime_id = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
      }
      
      
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "prod_endpoint" {
        name                  = "PROD"
        agent_runtime_id      = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
        depends_on = [aws_bedrockagentcore_agent_runtime_endpoint.dev_endpoint] # Prevents ConflictException
      }
    ''',
    'terraform/main.tf': '''
      terraform {
        required_providers {
          aws = {
            source = "hashicorp/aws"
            version = ">= 6.19"
          }
        }
      
        required_version = ">= 1.2"
      }
      
      output "agentcore_runtime_id" {
        description = "AgentCore Runtime ID"
        value       = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
      }
      
      output "mcp_lambda_arn" {
        description = "MCP Lambda Function ARN"
        value       = aws_lambda_function.mcp_lambda.arn
      }
      
      output "ecr_repository_url" {
        description = "ECR Repository URL"
        value       = aws_ecr_repository.agentcore_terraform_runtime.repository_url
      }
    ''',
    'terraform/terraform.tfvars': '''
      # Application Configuration
      app_name = "testProj"
      
      # Runtime Version for PROD endpoint
      # Update this value when you want to promote a new version to production
      # DEV endpoint always uses the latest version automatically
      agent_runtime_version = "1"
    ''',
    'terraform/variables.tf': '''
      # Variables
      variable "app_name" {
        description = "Application name"
        type        = string
      }
      
      variable "agent_runtime_version" {
        description = "Runtime version for PROD endpoint"
        type        = string
        default     = "1"
      }
      
      data "aws_region" "current" { }
      
      data "aws_caller_identity" "current" {}
    ''',
  })
# ---
# name: test_cdk_snapshots[scenario_1][scenario_1-OpenAIAgents-default settings; stm memory]
  dict({
    '.bedrock_agentcore.yaml': '''
      default_agent: bootstrap_agent
      is_agentcore_bootstrap_project: true
      agents:
        bootstrap_agent:
          name: bootstrap_agent
          entrypoint: <PROJECT_ROOT>/src
          deployment_type: container
          aws:
            region: null
          bedrock_agentcore:
            agent_id: null
            agent_arn: null
            agent_session_id: null
  
    ''',
    'README.md': '''
      This is a monorepo generated by the agentcore bootstrap CLI tool!
      
      # Deploying
      
      If you want to skip the explanation of the `src/` directory and deploy straight away, see the below terraform/ section.
      
      # Layout
      
      There are three main directories created in this project: `src`, `mcp`, and `terraform`. In a monorepo setup all of the code—source, test, and IaC for deployment—is contained in one repository. Everything needed to
      define runtime code and deploy it into your AWS account is contained in this project.
      
      The `terraform` directory models all of the Bedrock AgentCore and related resources. There are direct references between `terraform` and the runtime `src/`. For example, the IaC code expects to find the
      Dockerfile at a specific relative path.
      
      ## src/
      
      The `src/` directory is where you will find the runtime code.
      
      Start with main entrypoint to the generated app, `src/main.py`. This file defines an agent using OpenAIAgents and defines an entrypoint method with the Bedrock AgentCore SDK:
      
      ```
      @app.entrypoint
      def invoke(payload):
          # assume payload input is structured as { "prompt": "<user input>" }
      ```
      
      Next there is the `src/mcp_client` directory. Here you will find `client.py`. This file defines an MCP client from the chosen OpenAIAgents library. That client points to the
      gateway URL for the AgentCore gateway that is modeled in the `terraform` directory. Behind that gateway is a custom MCP tool modeled as a Lambda function (see below `mcp/` section for more details).
      The authorizer for the gateway is a Cognito app client that is modeled in the `terraform` directory. A call using
      the client_credentials flow is defined in `_get_access_token()`.
      
      ## mcp/
      
      The `mcp/` directory defines a simple Python tool that meets the MCP specification called `placeholder_tool`. The specification for the tool's inputs is defined in the inline schema in the modeled
      `terraform` directory. When replacing the dummy implementation in `mcp/lambda/handler.py`, make sure to update the corresponding Lambda target schema to reflect the changes before re-deploying.
      The `placeholder_tool` implementation demonstrates the tool name and input payload conventions of a Lambda behind the gateway. The gateway supports [flexible target types](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-add-target-api.html).
      
      ## terraform/
      
      This directory contains a Terraform project that models AgentCore and related AWS resources.
      
      First check that the `terraform` binary is installed with version >= 1.2:
      - `terraform version -json | jq -r '.terraform_version'`
      - Terraform install [webpage](https://developer.hashicorp.com/terraform/install)
      
      - shorthand: `cd terraform && terraform init && terraform apply`
      - navigate to the `terraform` directory: `cd terraform`
      - download dependencies: `terraform init`
      - [optional] overview resources to be deployed: `terraform plan`
      - deploy to AWS: `terraform apply`
      
      # `agentcore bootstrap` output
      
      Primarily, `agentcore bootstrap` outputs the directory that this `README.md` file is contained in. Nothing is deployed into AWS automatically.
      Execute the appropriate deployment commands in the `terraform` directory to deploy.
      
      There is also a `.bedrock_agentcore.yaml` file output in the `testProj` directory. This file contains a minimal definition with your agent name when it is created. After deploying the project, when running
      `agentcore invoke` or `agentcore status`, the command updates `.bedrock_agentcore.yaml` with the ID and ARN of your runtime so the CLI can successfully call the runtime using boto3.
      
      # Invoking the deployed Runtime
      
      The two easiest ways to invoke your runtime after deploying:
      
      1. `agentcore invoke`
         Example:
         ```
         agentcore invoke '{"prompt": "what can you do?"}'
         ```
      
      2. Navigate to the “Test Console” page in the Bedrock AgentCore AWS console. Select your runtime and the `DEFAULT` version. Provide an input.
         Example:
         ```
         {"prompt": "what can you do?"}
         ```
    ''',
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              → e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/.dockerignore': '''
      # Build artifacts
      build/
      dist/
      *.egg-info/
      *.egg
      
      # Python cache
      __pycache__/
      __pycache__*
      *.py[cod]
      *$py.class
      *.so
      .Python
      
      # Virtual environments
      .venv/
      .env
      venv/
      env/
      ENV/
      
      # Testing
      .pytest_cache/
      .coverage
      .coverage*
      htmlcov/
      .tox/
      *.cover
      .hypothesis/
      .mypy_cache/
      .ruff_cache/
      
      # Development
      *.log
      *.bak
      *.swp
      *.swo
      *~
      .DS_Store
      
      # IDEs
      .vscode/
      .idea/
      
      # Version control
      .git/
      .gitignore
      .gitattributes
      
      # Documentation
      docs/
      
      # CI/CD
      .github/
      .gitlab-ci.yml
      .travis.yml
      
      # Project specific
      tests/
      
      # Bedrock AgentCore specific - keep config but exclude runtime files
      .bedrock_agentcore.yaml
      .dockerignore
      .bedrock_agentcore/
      
      # Keep wheelhouse for offline installations
      # wheelhouse/
      
      # Monorepo directories
      cdk/
      terraform/
  
    ''',
    'src/Dockerfile': '''
      FROM ghcr.io/astral-sh/uv:python3.10-bookworm-slim
      WORKDIR /app
      
      # All environment variables in one layer
      ENV UV_SYSTEM_PYTHON=1 \
          UV_COMPILE_BYTECODE=1 \
          UV_NO_PROGRESS=1 \
          PYTHONUNBUFFERED=1 \
          DOCKER_CONTAINER=1
      
      
      
      COPY pyproject.toml pyproject.toml
      # Install from requirements file
      RUN uv pip install -r pyproject.toml
      
      
      
      
      RUN uv pip install aws-opentelemetry-distro>=0.10.1
      
      
      # Signal that this is running in Docker for host binding logic
      ENV DOCKER_CONTAINER=1
      
      # Create non-root user
      RUN useradd -m -u 1000 bedrock_agentcore
      USER bedrock_agentcore
      
      EXPOSE 9000
      EXPOSE 8000
      EXPOSE 8080
      
      # Copy entire project (respecting .dockerignore)
      COPY . .
      
      # Use the full module path
      
      CMD ["opentelemetry-instrument", "python", "-m", "main"]
  
    ''',
    'src/main.py': '''
      from agents import Agent, Runner, function_tool
      from bedrock_agentcore.runtime import BedrockAgentCoreApp
      from mcp_client.client import get_streamable_http_mcp_client
      import logging
      import sys
      
      # Set up logging
      logging.basicConfig(
          level=logging.DEBUG,
          format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
          handlers=[
              logging.StreamHandler(sys.stdout)
          ]
      )
      
      logger = logging.getLogger(__name__)
      
      # Define a simple function tool
      @function_tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Import AgentCore Gateway as Streamable HTTP MCP Server
      mcp_server = get_streamable_http_mcp_client()
      
      # Define an Agent with tools
      async def main(query):
          try:
              async with mcp_server as server:
                  agent = Agent(
                      name="bootstrap_agent",
                      mcp_servers=[server],
                      tools=[add_numbers]
                  )
                  result = await Runner.run(agent, query)
                  return result
          except Exception as e:
              logger.error(f"Error during agent execution: {e}", exc_info=True)
              raise e
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      
      @app.entrypoint
      async def agent_invocation(payload, context):
          # assume payload input is structured as { "prompt": "<user input>" }
      
          # Process the user prompt
          prompt = payload.get("prompt", "What is Agentic AI?")
      
          # Run the agent
          result = await main(prompt)
      
          # Return result
          return {"result": result.final_output}
      
      
      if __name__== "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from agents.mcp import MCPServerStreamableHttp
      import requests
      
      COGNITO_TOKEN_URL = os.getenv("COGNITO_TOKEN_URL")
      COGNITO_CLIENT_ID = os.getenv("COGNITO_CLIENT_ID")
      COGNITO_CLIENT_SECRET = os.getenv("COGNITO_CLIENT_SECRET")
      COGNITO_SCOPE = os.getenv("COGNITO_SCOPE")
      
      def _get_access_token():
          """
          Make a POST request to the Cognito OAuth token URL using client credentials.
          """
          response = requests.post(
              COGNITO_TOKEN_URL,
              auth=(COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET),
              data={
                  "grant_type": "client_credentials",
                  "scope": COGNITO_SCOPE,
              },
              headers={"Content-Type": "application/x-www-form-urlencoded"},
          )
          return response.json()["access_token"]
      
      
      def get_streamable_http_mcp_client() -> MCPServerStreamableHttp:
          """
          Returns an MCP Client for AgentCore Gateway compatible with OpenAI Agents SDK
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MCPServerStreamableHttp(
              name="AgentCore Gateway MCP",
              params={
                  "url": gateway_url,
                  "headers": {
                      "Authorization": f"Bearer {access_token}"
                  }
              }
          )
    ''',
    'src/pyproject.toml': '''
      [build-system]
      requires = ["setuptools>=68", "wheel"]
      build-backend = "setuptools.build_meta"
      
      [project]
      name = "testProj"
      version = "0.1.0"
      requires-python = ">=3.10"
      
      dependencies = [
          "bedrock-agentcore >= 1.0.3",
          "openai-agents>=0.4.2",
          "requests >= 2.32.5"
      ]
    ''',
    'terraform': None,
    'terraform/bedrock_agentcore.tf': '''
      ################################################################################
      # ECR Repository
      ################################################################################
      resource "aws_ecr_repository" "agentcore_terraform_runtime" {
        name                 = "bedrock-agentcore/${lower(var.app_name)}"
        image_tag_mutability = "MUTABLE"
      
        image_scanning_configuration {
          scan_on_push = true
        }
      
        encryption_configuration {
          encryption_type = "KMS"
        }
      }
      
      data "aws_ecr_authorization_token" "token" {}
      
      locals {
        src_files = fileset("../${path.root}/src", "**")
        src_hashes = [
          for f in local.src_files :
          filesha256("../${path.root}/src/${f}")
        ]
      
        # Collapse all file hashes into one
        src_hash = sha256(join("", local.src_hashes))
      }
      
      resource "null_resource" "docker_image" {
        depends_on = [aws_ecr_repository.agentcore_terraform_runtime]
      
        triggers = {
          src_hash = local.src_hash
        }
      
        provisioner "local-exec" {
          interpreter = ["/bin/bash", "-c"]
          command     = <<EOF
            source ~/.bash_profile || source ~/.profile || true
      
            if ! command -v docker &> /dev/null; then
              echo "Docker is not installed or not in PATH. Please install Docker and try again."
              exit 1
            fi
      
            aws ecr get-login-password | docker login --username AWS --password-stdin ${data.aws_ecr_authorization_token.token.proxy_endpoint}
      
            docker build -t ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest ../${path.root}/src
      
            docker push ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest
          EOF
        }
      }
      
      
      ################################################################################
      # MCP Lambda Function
      ################################################################################
      data "archive_file" "mcp_lambda_zip" {
        type        = "zip"
        source_dir  = "../${path.root}/mcp/lambda"
        output_path = "../${path.root}/mcp_lambda.zip"
      }
      
      resource "aws_lambda_function" "mcp_lambda" {
        function_name = "${var.app_name}-McpLambda"
        role          = aws_iam_role.mcp_lambda_role.arn
        handler       = "handler.lambda_handler"
        runtime       = "python3.12"
      
        filename         = data.archive_file.mcp_lambda_zip.output_path
        source_code_hash = data.archive_file.mcp_lambda_zip.output_base64sha256
      }
      
      resource "aws_iam_role" "mcp_lambda_role" {
        name = "${var.app_name}-McpLambdaRole"
      
        assume_role_policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action = "sts:AssumeRole"
            Effect = "Allow"
            Principal = {
              Service = "lambda.amazonaws.com"
            }
          }]
        })
      }
      
      resource "aws_iam_role_policy_attachment" "mcp_lambda_basic" {
        role       = aws_iam_role.mcp_lambda_role.name
        policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      }
      
      ################################################################################
      # AgentCore Gateway Roles
      ################################################################################
      
      resource "aws_iam_role" "agentcore_gateway_role" {
        name               = "${var.app_name}-AgentCoreGatewayRole"
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      resource "aws_iam_role_policy_attachment" "agentcore_gateway_permissions" {
        role       = aws_iam_role.agentcore_gateway_role.name
        policy_arn = "arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess"
      }
      
      resource "aws_iam_role_policy" "agentcore_gateway_lambda_invoke" {
        role = aws_iam_role.agentcore_gateway_role.id
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action   = ["lambda:InvokeFunction"]
            Effect   = "Allow"
            Resource = [aws_lambda_function.mcp_lambda.arn]
          }]
        })
      }
      
      ################################################################################
      # AgentCore Gateway Inbound Auth - Cognito
      ################################################################################
      
      resource "aws_cognito_user_pool" "cognito_user_pool" {
        name = "${var.app_name}-CognitoUserPool"
      }
      
      resource "aws_cognito_resource_server" "cognito_resource_server" {
        identifier   = "${var.app_name}-CognitoResourceServer"
        name         = "${var.app_name}-CognitoResourceServer"
        user_pool_id = aws_cognito_user_pool.cognito_user_pool.id
        scope {
          scope_description = "Basic access to ${var.app_name}"
          scope_name        = "basic"
        }
      }
      
      resource "aws_cognito_user_pool_client" "cognito_app_client" {
        name                                 = "${var.app_name}-CognitoUserPoolClient"
        user_pool_id                         = aws_cognito_user_pool.cognito_user_pool.id
        generate_secret                      = true
        allowed_oauth_flows                  = ["client_credentials"]
        allowed_oauth_flows_user_pool_client = true
        allowed_oauth_scopes                 = ["${aws_cognito_resource_server.cognito_resource_server.identifier}/basic"]
        supported_identity_providers         = ["COGNITO"]
      }
      
      resource "aws_cognito_user_pool_domain" "cognito_domain" {
        domain       = "${var.app_name}-${data.aws_region.current.region}"
        user_pool_id = aws_cognito_user_pool.cognito_user_pool.id
      }
      
      locals {
        cognito_discovery_url = "https://cognito-idp.${data.aws_region.current.region}.amazonaws.com/${aws_cognito_user_pool.cognito_user_pool.id}/.well-known/openid-configuration"
      }
      
      ################################################################################
      # AgentCore Gateway
      ################################################################################
      
      resource "aws_bedrockagentcore_gateway" "agentcore_gateway" {
        name            = "${var.app_name}-AgentCoreGateway"
        protocol_type   = "MCP"
        role_arn        = aws_iam_role.agentcore_gateway_role.arn
        authorizer_type = "CUSTOM_JWT"
        authorizer_configuration {
          custom_jwt_authorizer {
            discovery_url   = local.cognito_discovery_url
            allowed_clients = [aws_cognito_user_pool_client.cognito_app_client.id]
          }
        }
      }
      
      resource "aws_bedrockagentcore_gateway_target" "agentcore_gateway_lambda_target" {
        name               = "${var.app_name}-AgentCoreGatewayTarget"
        gateway_identifier = aws_bedrockagentcore_gateway.agentcore_gateway.gateway_id
      
        credential_provider_configuration {
          gateway_iam_role {}
        }
      
        target_configuration {
          mcp {
            lambda {
              lambda_arn = aws_lambda_function.mcp_lambda.arn
      
              tool_schema {
                inline_payload {
                  name        = "placeholder_tool"
                  description = "Placeholder tool (no-op)."
                  input_schema {
                    type        = "object"
                    description = "Example input schema for placeholder tool"
                    property {
                      name        = "string_param"
                      type        = "string"
                      description = "Example string parameter."
                    }
                    property {
                      name        = "int_param"
                      type        = "integer"
                      description = "Example integer parameter."
                    }
                    property {
                      name        = "float_array_param"
                      type        = "array"
                      description = "Example float array parameter."
                      items {
                        type = "number"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime IAM Roles
      ################################################################################
      
      data "aws_iam_policy_document" "bedrock_agentcore_assume_role" {
        statement {
          effect  = "Allow"
          actions = ["sts:AssumeRole"]
          principals {
            type        = "Service"
            identifiers = ["bedrock-agentcore.amazonaws.com"]
          }
        }
      }
      
      resource "aws_iam_role" "agentcore_runtime_execution_role" {
        name        = "${var.app_name}-AgentCoreRuntimeRole"
        description = "Execution role for Bedrock AgentCore Runtime"
      
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html#runtime-permissions-execution
      resource "aws_iam_role_policy" "agentcore_runtime_execution_role_policy" {
        role   = aws_iam_role.agentcore_runtime_execution_role.id
        name = "${var.app_name}-AgentCoreRuntimeExecutionPolicy"
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "ECRImageAccess"
              Effect = "Allow"
              Action = [
                "ecr:BatchGetImage",
                "ecr:GetDownloadUrlForLayer",
              ]
              Resource = [
                "arn:aws:ecr:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:repository/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogStreams",
                "logs:CreateLogGroup",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogGroups",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:CreateLogStream",
                "logs:PutLogEvents",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*",
              ]
            },
            {
              Sid    = "ECRTokenAccess"
              Effect = "Allow"
              Action = [
                "ecr:GetAuthorizationToken",
              ]
              Resource = "*"
            },
            {
              Effect = "Allow"
              Action = [
                "xray:PutTraceSegments",
                "xray:PutTelemetryRecords",
                "xray:GetSamplingRules",
                "xray:GetSamplingTargets",
              ]
              Resource = [
                "*",
              ]
            },
            {
              Effect   = "Allow"
              Resource = "*"
              Action   = "cloudwatch:PutMetricData"
              Condition = {
                StringEquals = {
                  "cloudwatch:namespace" = "bedrock-agentcore"
                }
              }
            },
            {
              Sid    = "GetAgentAccessToken"
              Effect = "Allow"
              Action = [
                "bedrock-agentcore:GetWorkloadAccessToken",
                "bedrock-agentcore:GetWorkloadAccessTokenForJWT",
                "bedrock-agentcore:GetWorkloadAccessTokenForUserId",
              ]
              Resource = [
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default",
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default/workload-identity/agentName-*",
              ]
            },
            {
              Sid    = "BedrockModelInvocation"
              Effect = "Allow"
              Action = [
                "bedrock:InvokeModel",
                "bedrock:InvokeModelWithResponseStream",
              ]
              Resource = [
                "arn:aws:bedrock:*::foundation-model/*",
                "arn:aws:bedrock:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:*",
              ]
            },
          ]
        })
      }
      
      
      ################################################################################
      # AgentCore Memory
      ################################################################################
      resource "aws_bedrockagentcore_memory" "agentcore_memory" {
        name                  = "bootstrap_agent_memory"
        description           = "Memory resource with 30 days event expiry"
        event_expiry_duration = 30
      }
      # Add a built-in strategy from https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/built-in-strategies.html or define a custom one
      # Example of adding semantic memory
      # resource "aws_bedrockagentcore_memory_strategy" "semantic" {
      #  name        = "semantic-strategy"
      #  memory_id   = aws_bedrockagentcore_memory.agentcore_memory.id
      #  type        = "SEMANTIC"
      #  description = "Semantic understanding strategy"
      #  namespaces  = ["default"]
      # }
      
      ################################################################################
      # AgentCore Runtime
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime" "agentcore_runtime" {
        agent_runtime_name = "bootstrap_agent"
        role_arn           = aws_iam_role.agentcore_runtime_execution_role.arn
      
        agent_runtime_artifact {
          container_configuration {
            container_uri = "${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest"
          }
        }
      
        depends_on = [null_resource.docker_image, aws_bedrockagentcore_memory.agentcore_memory]
      
        network_configuration {
          network_mode = "PUBLIC"
        }
        environment_variables = {
          MEMORY_ID = aws_bedrockagentcore_memory.agentcore_memory.id
          GATEWAY_URL = aws_bedrockagentcore_gateway.agentcore_gateway.gateway_url
          COGNITO_CLIENT_ID     = aws_cognito_user_pool_client.cognito_app_client.id
          COGNITO_CLIENT_SECRET = aws_cognito_user_pool_client.cognito_app_client.client_secret
          COGNITO_TOKEN_URL     = "https://${aws_cognito_user_pool_domain.cognito_domain.domain}.auth.${data.aws_region.current.region}.amazoncognito.com/oauth2/token"
          COGNITO_SCOPE         = "${aws_cognito_resource_server.cognito_resource_server.identifier}/basic"
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime Endpoints
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "dev_endpoint" {
        name             = "DEV"
        agent_runtime_id = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
      }
      
      
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "prod_endpoint" {
        name                  = "PROD"
        agent_runtime_id      = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
        depends_on = [aws_bedrockagentcore_agent_runtime_endpoint.dev_endpoint] # Prevents ConflictException
      }
    ''',
    'terraform/main.tf': '''
      terraform {
        required_providers {
          aws = {
            source = "hashicorp/aws"
            version = ">= 6.19"
          }
        }
      
        required_version = ">= 1.2"
      }
      
      output "agentcore_runtime_id" {
        description = "AgentCore Runtime ID"
        value       = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
      }
      
      output "mcp_lambda_arn" {
        description = "MCP Lambda Function ARN"
        value       = aws_lambda_function.mcp_lambda.arn
      }
      
      output "ecr_repository_url" {
        description = "ECR Repository URL"
        value       = aws_ecr_repository.agentcore_terraform_runtime.repository_url
      }
    ''',
    'terraform/terraform.tfvars': '''
      # Application Configuration
      app_name = "testProj"
      
      # Runtime Version for PROD endpoint
      # Update this value when you want to promote a new version to production
      # DEV endpoint always uses the latest version automatically
      agent_runtime_version = "1"
    ''',
    'terraform/variables.tf': '''
      # Variables
      variable "app_name" {
        description = "Application name"
        type        = string
      }
      
      variable "agent_runtime_version" {
        description = "Runtime version for PROD endpoint"
        type        = string
        default     = "1"
      }
      
      data "aws_region" "current" { }
      
      data "aws_caller_identity" "current" {}
    ''',
  })
# ---
# name: test_cdk_snapshots[scenario_2][scenario_2-None-source provided; no sdk provider]
  dict({
    '.bedrock_agentcore.yaml': '''
      default_agent: custom_agent
      is_agentcore_bootstrap_project: true
      agents:
        custom_agent:
          name: custom_agent
          entrypoint: <PROJECT_ROOT>/src
          deployment_type: container
          aws:
            region: null
          bedrock_agentcore:
            agent_id: null
            agent_arn: null
            agent_session_id: null
  
    ''',
    'src': None,
    'src/.dockerignore': 'Dummy Dockerignore!',
    'src/Dockerfile': 'Dummy Dockerfile!',
    'src/requirements.txt': 'strands-agents >= 1.0.0',
    'src/src': None,
    'src/src/agent': None,
    'src/src/agent/main.py': '''
      from strands import Agent
      
      Agent("run!")
    ''',
    'terraform': None,
    'terraform/bedrock_agentcore.tf': '''
      ################################################################################
      # ECR Repository
      ################################################################################
      resource "aws_ecr_repository" "agentcore_terraform_runtime" {
        name                 = "bedrock-agentcore/${lower(var.app_name)}"
        image_tag_mutability = "MUTABLE"
      
        image_scanning_configuration {
          scan_on_push = true
        }
      
        encryption_configuration {
          encryption_type = "KMS"
        }
      }
      
      data "aws_ecr_authorization_token" "token" {}
      
      locals {
        src_files = fileset("../${path.root}/src", "**")
        src_hashes = [
          for f in local.src_files :
          filesha256("../${path.root}/src/${f}")
        ]
      
        # Collapse all file hashes into one
        src_hash = sha256(join("", local.src_hashes))
      }
      
      resource "null_resource" "docker_image" {
        depends_on = [aws_ecr_repository.agentcore_terraform_runtime]
      
        triggers = {
          src_hash = local.src_hash
        }
      
        provisioner "local-exec" {
          interpreter = ["/bin/bash", "-c"]
          command     = <<EOF
            source ~/.bash_profile || source ~/.profile || true
      
            if ! command -v docker &> /dev/null; then
              echo "Docker is not installed or not in PATH. Please install Docker and try again."
              exit 1
            fi
      
            aws ecr get-login-password | docker login --username AWS --password-stdin ${data.aws_ecr_authorization_token.token.proxy_endpoint}
      
            docker build -t ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest ../${path.root}/src
      
            docker push ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest
          EOF
        }
      }
      
      
      
      ################################################################################
      # AgentCore Runtime IAM Roles
      ################################################################################
      
      data "aws_iam_policy_document" "bedrock_agentcore_assume_role" {
        statement {
          effect  = "Allow"
          actions = ["sts:AssumeRole"]
          principals {
            type        = "Service"
            identifiers = ["bedrock-agentcore.amazonaws.com"]
          }
        }
      }
      
      resource "aws_iam_role" "agentcore_runtime_execution_role" {
        name        = "${var.app_name}-AgentCoreRuntimeRole"
        description = "Execution role for Bedrock AgentCore Runtime"
      
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html#runtime-permissions-execution
      resource "aws_iam_role_policy" "agentcore_runtime_execution_role_policy" {
        role   = aws_iam_role.agentcore_runtime_execution_role.id
        name = "${var.app_name}-AgentCoreRuntimeExecutionPolicy"
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "ECRImageAccess"
              Effect = "Allow"
              Action = [
                "ecr:BatchGetImage",
                "ecr:GetDownloadUrlForLayer",
              ]
              Resource = [
                "arn:aws:ecr:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:repository/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogStreams",
                "logs:CreateLogGroup",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogGroups",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:CreateLogStream",
                "logs:PutLogEvents",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*",
              ]
            },
            {
              Sid    = "ECRTokenAccess"
              Effect = "Allow"
              Action = [
                "ecr:GetAuthorizationToken",
              ]
              Resource = "*"
            },
            {
              Effect = "Allow"
              Action = [
                "xray:PutTraceSegments",
                "xray:PutTelemetryRecords",
                "xray:GetSamplingRules",
                "xray:GetSamplingTargets",
              ]
              Resource = [
                "*",
              ]
            },
            {
              Effect   = "Allow"
              Resource = "*"
              Action   = "cloudwatch:PutMetricData"
              Condition = {
                StringEquals = {
                  "cloudwatch:namespace" = "bedrock-agentcore"
                }
              }
            },
            {
              Sid    = "GetAgentAccessToken"
              Effect = "Allow"
              Action = [
                "bedrock-agentcore:GetWorkloadAccessToken",
                "bedrock-agentcore:GetWorkloadAccessTokenForJWT",
                "bedrock-agentcore:GetWorkloadAccessTokenForUserId",
              ]
              Resource = [
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default",
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default/workload-identity/agentName-*",
              ]
            },
            {
              Sid    = "BedrockModelInvocation"
              Effect = "Allow"
              Action = [
                "bedrock:InvokeModel",
                "bedrock:InvokeModelWithResponseStream",
              ]
              Resource = [
                "arn:aws:bedrock:*::foundation-model/*",
                "arn:aws:bedrock:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:*",
              ]
            },
          ]
        })
      }
      
      
      ################################################################################
      # AgentCore Memory
      ################################################################################
      resource "aws_bedrockagentcore_memory" "agentcore_memory" {
        name                  = "bootstrap_agent_memory"
        description           = "Memory resource with 30 days event expiry"
        event_expiry_duration = 30
      }
      # Long Term Memory Configuration
      resource "aws_bedrockagentcore_memory_strategy" "user_preference_memory_strategy" {
        memory_id  = aws_bedrockagentcore_memory.agentcore_memory.id
        name       = "UserPreferences"
        namespaces = ["/users/{actorId}/preferences"]
        type       = "USER_PREFERENCE"
      }
      
      resource "aws_bedrockagentcore_memory_strategy" "semantic_memory_strategy" {
        memory_id  = aws_bedrockagentcore_memory.agentcore_memory.id
        name       = "SemanticFacts"
        namespaces = ["/users/{actorId}/facts"]
        type       = "SEMANTIC"
      }
      
      resource "aws_bedrockagentcore_memory_strategy" "summary_memory_strategy" {
        memory_id  = aws_bedrockagentcore_memory.agentcore_memory.id
        name       = "SessionSummaries"
        namespaces = ["/summaries/{actorId}/{sessionId}"]
        type       = "SUMMARIZATION"
      }
      
      ################################################################################
      # AgentCore Runtime
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime" "agentcore_runtime" {
        agent_runtime_name = "custom_agent"
        role_arn           = aws_iam_role.agentcore_runtime_execution_role.arn
      
        agent_runtime_artifact {
          container_configuration {
            container_uri = "${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest"
          }
        }
      
        depends_on = [null_resource.docker_image, aws_bedrockagentcore_memory.agentcore_memory]
      
        network_configuration {
          network_mode = "PUBLIC"
        }
        request_header_configuration {
          request_header_allowlist = ["x-amzn-bedrock", "x-amzn-agentcore"]
        }
        environment_variables = {
          MEMORY_ID = aws_bedrockagentcore_memory.agentcore_memory.id
        }
        authorizer_configuration {
          custom_jwt_authorizer {
            discovery_url    = "https://aws.dev"
            allowed_clients  = ["12345", "6789"]
          }
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime Endpoints
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "dev_endpoint" {
        name             = "DEV"
        agent_runtime_id = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
      }
      
      
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "prod_endpoint" {
        name                  = "PROD"
        agent_runtime_id      = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
        depends_on = [aws_bedrockagentcore_agent_runtime_endpoint.dev_endpoint] # Prevents ConflictException
      }
    ''',
    'terraform/main.tf': '''
      terraform {
        required_providers {
          aws = {
            source = "hashicorp/aws"
            version = ">= 6.19"
          }
        }
      
        required_version = ">= 1.2"
      }
      
      output "agentcore_runtime_id" {
        description = "AgentCore Runtime ID"
        value       = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
      }
      
      output "mcp_lambda_arn" {
        description = "MCP Lambda Function ARN"
        value       = aws_lambda_function.mcp_lambda.arn
      }
      
      output "ecr_repository_url" {
        description = "ECR Repository URL"
        value       = aws_ecr_repository.agentcore_terraform_runtime.repository_url
      }
    ''',
    'terraform/terraform.tfvars': '''
      # Application Configuration
      app_name = "testProj"
      
      # Runtime Version for PROD endpoint
      # Update this value when you want to promote a new version to production
      # DEV endpoint always uses the latest version automatically
      agent_runtime_version = "1"
    ''',
    'terraform/variables.tf': '''
      # Variables
      variable "app_name" {
        description = "Application name"
        type        = string
      }
      
      variable "agent_runtime_version" {
        description = "Runtime version for PROD endpoint"
        type        = string
        default     = "1"
      }
      
      data "aws_region" "current" { }
      
      data "aws_caller_identity" "current" {}
    ''',
  })
# ---
# name: test_cdk_snapshots[scenario_3][scenario_3-LangGraph-lang-graph run bootstrap as standalone]
  dict({
    '.bedrock_agentcore.yaml': '''
      default_agent: testProj_Agent
      is_agentcore_bootstrap_project: true
      agents:
        testProj_Agent:
          name: testProj_Agent
          entrypoint: <PROJECT_ROOT>/src
          deployment_type: container
          aws:
            region: null
          bedrock_agentcore:
            agent_id: null
            agent_arn: null
            agent_session_id: null
  
    ''',
    'README.md': '''
      This is a monorepo generated by the agentcore bootstrap CLI tool!
      
      # Deploying
      
      If you want to skip the explanation of the `src/` directory and deploy straight away, see the below terraform/ section.
      
      # Layout
      
      There are three main directories created in this project: `src`, `mcp`, and `terraform`. In a monorepo setup all of the code—source, test, and IaC for deployment—is contained in one repository. Everything needed to
      define runtime code and deploy it into your AWS account is contained in this project.
      
      The `terraform` directory models all of the Bedrock AgentCore and related resources. There are direct references between `terraform` and the runtime `src/`. For example, the IaC code expects to find the
      Dockerfile at a specific relative path.
      
      ## src/
      
      The `src/` directory is where you will find the runtime code.
      
      Start with main entrypoint to the generated app, `src/main.py`. This file defines an agent using LangGraph and defines an entrypoint method with the Bedrock AgentCore SDK:
      
      ```
      @app.entrypoint
      def invoke(payload):
          # assume payload input is structured as { "prompt": "<user input>" }
      ```
      
      Next there is the `src/mcp_client` directory. Here you will find `client.py`. This file defines an MCP client from the chosen LangGraph library. That client points to the
      gateway URL for the AgentCore gateway that is modeled in the `terraform` directory. Behind that gateway is a custom MCP tool modeled as a Lambda function (see below `mcp/` section for more details).
      The authorizer for the gateway is a Cognito app client that is modeled in the `terraform` directory. A call using
      the client_credentials flow is defined in `_get_access_token()`.
      
      ## mcp/
      
      The `mcp/` directory defines a simple Python tool that meets the MCP specification called `placeholder_tool`. The specification for the tool's inputs is defined in the inline schema in the modeled
      `terraform` directory. When replacing the dummy implementation in `mcp/lambda/handler.py`, make sure to update the corresponding Lambda target schema to reflect the changes before re-deploying.
      The `placeholder_tool` implementation demonstrates the tool name and input payload conventions of a Lambda behind the gateway. The gateway supports [flexible target types](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-add-target-api.html).
      
      ## terraform/
      
      This directory contains a Terraform project that models AgentCore and related AWS resources.
      
      First check that the `terraform` binary is installed with version >= 1.2:
      - `terraform version -json | jq -r '.terraform_version'`
      - Terraform install [webpage](https://developer.hashicorp.com/terraform/install)
      
      - shorthand: `cd terraform && terraform init && terraform apply`
      - navigate to the `terraform` directory: `cd terraform`
      - download dependencies: `terraform init`
      - [optional] overview resources to be deployed: `terraform plan`
      - deploy to AWS: `terraform apply`
      
      # `agentcore bootstrap` output
      
      Primarily, `agentcore bootstrap` outputs the directory that this `README.md` file is contained in. Nothing is deployed into AWS automatically.
      Execute the appropriate deployment commands in the `terraform` directory to deploy.
      
      There is also a `.bedrock_agentcore.yaml` file output in the `testProj` directory. This file contains a minimal definition with your agent name when it is created. After deploying the project, when running
      `agentcore invoke` or `agentcore status`, the command updates `.bedrock_agentcore.yaml` with the ID and ARN of your runtime so the CLI can successfully call the runtime using boto3.
      
      # Invoking the deployed Runtime
      
      The two easiest ways to invoke your runtime after deploying:
      
      1. `agentcore invoke`
         Example:
         ```
         agentcore invoke '{"prompt": "what can you do?"}'
         ```
      
      2. Navigate to the “Test Console” page in the Bedrock AgentCore AWS console. Select your runtime and the `DEFAULT` version. Provide an input.
         Example:
         ```
         {"prompt": "what can you do?"}
         ```
    ''',
    'mcp': None,
    'mcp/lambda': None,
    'mcp/lambda/handler.py': '''
      import json
      from typing import Any, Dict
      
      
      def lambda_handler(event, context):
          """
          Generic Lambda handler for Bedrock AgentCore Gateway placeholder tool.
      
          Expected input:
              event: {
                  # optional tool arguments
                  "param_0": val0,
                  "param_1": val1,
                  ...
              }
      
          Context should contain:
              context.client_context.custom["bedrockAgentCoreToolName"]
              → e.g. "LambdaTarget___placeholder_tool"
          """
          try:
              extended_name = context.client_context.custom.get("bedrockAgentCoreToolName")
              tool_name = None
      
              # handle agentcore gateway tool naming convention
              # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/gateway-tool-naming.html
              if extended_name and "___" in extended_name:
                  tool_name = extended_name.split("___", 1)[1]
      
              if not tool_name:
                  return _response(400, {"error": "Missing tool name"})
      
              if tool_name != "placeholder_tool":
                  return _response(400, {"error": f"Unknown tool '{tool_name}'"})
      
              result = placeholder_tool(event)
              return _response(200, {"result": result})
      
          except Exception as e:
              return _response(500, {"system_error": str(e)})
      
      
      def _response(status_code: int, body: Dict[str, Any]):
          """Consistent JSON response wrapper."""
          return {"statusCode": status_code, "body": json.dumps(body)}
      
      
      def placeholder_tool(event: Dict[str, Any]):
          """
          no-op placeholder tool.
      
          Demonstrates argument passing from AgentCore Gateway.
          """
          return {
              "message": "Placeholder tool executed.",
              "string_param": event.get("string_param"),
              "int_param": event.get("int_param"),
              "float_array_param": event.get("float_array_param"),
              "event_args_received": event,
          }
    ''',
    'src': None,
    'src/.dockerignore': '''
      # Build artifacts
      build/
      dist/
      *.egg-info/
      *.egg
      
      # Python cache
      __pycache__/
      __pycache__*
      *.py[cod]
      *$py.class
      *.so
      .Python
      
      # Virtual environments
      .venv/
      .env
      venv/
      env/
      ENV/
      
      # Testing
      .pytest_cache/
      .coverage
      .coverage*
      htmlcov/
      .tox/
      *.cover
      .hypothesis/
      .mypy_cache/
      .ruff_cache/
      
      # Development
      *.log
      *.bak
      *.swp
      *.swo
      *~
      .DS_Store
      
      # IDEs
      .vscode/
      .idea/
      
      # Version control
      .git/
      .gitignore
      .gitattributes
      
      # Documentation
      docs/
      
      # CI/CD
      .github/
      .gitlab-ci.yml
      .travis.yml
      
      # Project specific
      tests/
      
      # Bedrock AgentCore specific - keep config but exclude runtime files
      .bedrock_agentcore.yaml
      .dockerignore
      .bedrock_agentcore/
      
      # Keep wheelhouse for offline installations
      # wheelhouse/
      
      # Monorepo directories
      cdk/
      terraform/
  
    ''',
    'src/Dockerfile': '''
      FROM ghcr.io/astral-sh/uv:python3.10-bookworm-slim
      WORKDIR /app
      
      # All environment variables in one layer
      ENV UV_SYSTEM_PYTHON=1 \
          UV_COMPILE_BYTECODE=1 \
          UV_NO_PROGRESS=1 \
          PYTHONUNBUFFERED=1 \
          DOCKER_CONTAINER=1
      
      
      
      COPY pyproject.toml pyproject.toml
      # Install from requirements file
      RUN uv pip install -r pyproject.toml
      
      
      
      
      RUN uv pip install aws-opentelemetry-distro>=0.10.1
      
      
      # Signal that this is running in Docker for host binding logic
      ENV DOCKER_CONTAINER=1
      
      # Create non-root user
      RUN useradd -m -u 1000 bedrock_agentcore
      USER bedrock_agentcore
      
      EXPOSE 9000
      EXPOSE 8000
      EXPOSE 8080
      
      # Copy entire project (respecting .dockerignore)
      COPY . .
      
      # Use the full module path
      
      CMD ["opentelemetry-instrument", "python", "-m", "main"]
  
    ''',
    'src/main.py': '''
      from langchain_core.messages import HumanMessage
      from langchain.agents import create_agent
      from langchain_aws import ChatBedrock
      from langchain.tools import tool
      from bedrock_agentcore import BedrockAgentCoreApp
      from mcp_client.client import get_streamable_http_mcp_client
      
      MODEL_ID="anthropic.claude-3-5-sonnet-20240620-v1:0"
      
      # Initialize the model client
      llm = ChatBedrock(model_id=MODEL_ID)
      
      # Define a simple function tool
      @tool
      def add_numbers(a: int, b: int) -> int:
          """Return the sum of two numbers"""
          return a+b
      
      # Import AgentCore Gateway as Streamable HTTP MCP Client
      mcp_client = get_streamable_http_mcp_client()
      
      # Integrate with Bedrock AgentCore
      app = BedrockAgentCoreApp()
      
      @app.entrypoint
      async def invoke(payload):
          # assume payload input is structured as { "prompt": "<user input>" }
      
          # Load MCP Tools
          tools = await mcp_client.get_tools()
      
          # Define the agent
          graph = create_agent(llm, tools=[add_numbers] + tools)
      
          # Process the user prompt
          prompt = payload.get("prompt", "What is Agentic AI?")
      
          # Run the agent
          result = await graph.ainvoke({"messages": [HumanMessage(content=prompt)]})
      
          # Return result
          return {
              "result": result["messages"][-1].content
          }
      
      if __name__ == "__main__":
          app.run()
    ''',
    'src/mcp_client': None,
    'src/mcp_client/client.py': '''
      import os
      from langchain_mcp_adapters.client import MultiServerMCPClient
      import requests
      
      COGNITO_TOKEN_URL = os.getenv("COGNITO_TOKEN_URL")
      COGNITO_CLIENT_ID = os.getenv("COGNITO_CLIENT_ID")
      COGNITO_CLIENT_SECRET = os.getenv("COGNITO_CLIENT_SECRET")
      COGNITO_SCOPE = os.getenv("COGNITO_SCOPE")
      
      def _get_access_token():
          """
          Make a POST request to the Cognito OAuth token URL using client credentials.
          """
          response = requests.post(
              COGNITO_TOKEN_URL,
              auth=(COGNITO_CLIENT_ID, COGNITO_CLIENT_SECRET),
              data={
                  "grant_type": "client_credentials",
                  "scope": COGNITO_SCOPE,
              },
              headers={"Content-Type": "application/x-www-form-urlencoded"},
          )
          return response.json()["access_token"]
      
      
      def get_streamable_http_mcp_client() -> MultiServerMCPClient:
          """
          Returns an MCP Client for AgentCore Gateway compatible with LangGraph
          """
          gateway_url = os.getenv("GATEWAY_URL")
          if not gateway_url:
              raise RuntimeError("Missing required environment variable: GATEWAY_URL")
          access_token = _get_access_token()
          return MultiServerMCPClient(
              {
                  "agentcore_gateway": {
                      "transport": "streamable_http",
                      "url": gateway_url,
                      "headers": {
                          "Authorization": f"Bearer {access_token}"
                      }
                  }
              }
          )
    ''',
    'src/pyproject.toml': '''
      [build-system]
      requires = ["setuptools>=68", "wheel"]
      build-backend = "setuptools.build_meta"
      
      [project]
      name = "testProj"
      version = "0.1.0"
      requires-python = ">=3.10"
      
      dependencies = [
          "bedrock-agentcore >= 1.0.3",
          "langchain >= 1.0.3",
          "langchain-mcp-adapters >= 0.1.11",
          "langchain_aws >= 1.0.0",
          "langgraph >= 1.0.2",
          "mcp >= 1.19.0",
          "requests >= 2.32.5"
      ]
    ''',
    'terraform': None,
    'terraform/bedrock_agentcore.tf': '''
      ################################################################################
      # ECR Repository
      ################################################################################
      resource "aws_ecr_repository" "agentcore_terraform_runtime" {
        name                 = "bedrock-agentcore/${lower(var.app_name)}"
        image_tag_mutability = "MUTABLE"
      
        image_scanning_configuration {
          scan_on_push = true
        }
      
        encryption_configuration {
          encryption_type = "KMS"
        }
      }
      
      data "aws_ecr_authorization_token" "token" {}
      
      locals {
        src_files = fileset("../${path.root}/src", "**")
        src_hashes = [
          for f in local.src_files :
          filesha256("../${path.root}/src/${f}")
        ]
      
        # Collapse all file hashes into one
        src_hash = sha256(join("", local.src_hashes))
      }
      
      resource "null_resource" "docker_image" {
        depends_on = [aws_ecr_repository.agentcore_terraform_runtime]
      
        triggers = {
          src_hash = local.src_hash
        }
      
        provisioner "local-exec" {
          interpreter = ["/bin/bash", "-c"]
          command     = <<EOF
            source ~/.bash_profile || source ~/.profile || true
      
            if ! command -v docker &> /dev/null; then
              echo "Docker is not installed or not in PATH. Please install Docker and try again."
              exit 1
            fi
      
            aws ecr get-login-password | docker login --username AWS --password-stdin ${data.aws_ecr_authorization_token.token.proxy_endpoint}
      
            docker build -t ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest ../${path.root}/src
      
            docker push ${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest
          EOF
        }
      }
      
      
      ################################################################################
      # MCP Lambda Function
      ################################################################################
      data "archive_file" "mcp_lambda_zip" {
        type        = "zip"
        source_dir  = "../${path.root}/mcp/lambda"
        output_path = "../${path.root}/mcp_lambda.zip"
      }
      
      resource "aws_lambda_function" "mcp_lambda" {
        function_name = "${var.app_name}-McpLambda"
        role          = aws_iam_role.mcp_lambda_role.arn
        handler       = "handler.lambda_handler"
        runtime       = "python3.12"
      
        filename         = data.archive_file.mcp_lambda_zip.output_path
        source_code_hash = data.archive_file.mcp_lambda_zip.output_base64sha256
      }
      
      resource "aws_iam_role" "mcp_lambda_role" {
        name = "${var.app_name}-McpLambdaRole"
      
        assume_role_policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action = "sts:AssumeRole"
            Effect = "Allow"
            Principal = {
              Service = "lambda.amazonaws.com"
            }
          }]
        })
      }
      
      resource "aws_iam_role_policy_attachment" "mcp_lambda_basic" {
        role       = aws_iam_role.mcp_lambda_role.name
        policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      }
      
      ################################################################################
      # AgentCore Gateway Roles
      ################################################################################
      
      resource "aws_iam_role" "agentcore_gateway_role" {
        name               = "${var.app_name}-AgentCoreGatewayRole"
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      resource "aws_iam_role_policy_attachment" "agentcore_gateway_permissions" {
        role       = aws_iam_role.agentcore_gateway_role.name
        policy_arn = "arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess"
      }
      
      resource "aws_iam_role_policy" "agentcore_gateway_lambda_invoke" {
        role = aws_iam_role.agentcore_gateway_role.id
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action   = ["lambda:InvokeFunction"]
            Effect   = "Allow"
            Resource = [aws_lambda_function.mcp_lambda.arn]
          }]
        })
      }
      
      ################################################################################
      # AgentCore Gateway Inbound Auth - Cognito
      ################################################################################
      
      resource "aws_cognito_user_pool" "cognito_user_pool" {
        name = "${var.app_name}-CognitoUserPool"
      }
      
      resource "aws_cognito_resource_server" "cognito_resource_server" {
        identifier   = "${var.app_name}-CognitoResourceServer"
        name         = "${var.app_name}-CognitoResourceServer"
        user_pool_id = aws_cognito_user_pool.cognito_user_pool.id
        scope {
          scope_description = "Basic access to ${var.app_name}"
          scope_name        = "basic"
        }
      }
      
      resource "aws_cognito_user_pool_client" "cognito_app_client" {
        name                                 = "${var.app_name}-CognitoUserPoolClient"
        user_pool_id                         = aws_cognito_user_pool.cognito_user_pool.id
        generate_secret                      = true
        allowed_oauth_flows                  = ["client_credentials"]
        allowed_oauth_flows_user_pool_client = true
        allowed_oauth_scopes                 = ["${aws_cognito_resource_server.cognito_resource_server.identifier}/basic"]
        supported_identity_providers         = ["COGNITO"]
      }
      
      resource "aws_cognito_user_pool_domain" "cognito_domain" {
        domain       = "${var.app_name}-${data.aws_region.current.region}"
        user_pool_id = aws_cognito_user_pool.cognito_user_pool.id
      }
      
      locals {
        cognito_discovery_url = "https://cognito-idp.${data.aws_region.current.region}.amazonaws.com/${aws_cognito_user_pool.cognito_user_pool.id}/.well-known/openid-configuration"
      }
      
      ################################################################################
      # AgentCore Gateway
      ################################################################################
      
      resource "aws_bedrockagentcore_gateway" "agentcore_gateway" {
        name            = "${var.app_name}-AgentCoreGateway"
        protocol_type   = "MCP"
        role_arn        = aws_iam_role.agentcore_gateway_role.arn
        authorizer_type = "CUSTOM_JWT"
        authorizer_configuration {
          custom_jwt_authorizer {
            discovery_url   = local.cognito_discovery_url
            allowed_clients = [aws_cognito_user_pool_client.cognito_app_client.id]
          }
        }
      }
      
      resource "aws_bedrockagentcore_gateway_target" "agentcore_gateway_lambda_target" {
        name               = "${var.app_name}-AgentCoreGatewayTarget"
        gateway_identifier = aws_bedrockagentcore_gateway.agentcore_gateway.gateway_id
      
        credential_provider_configuration {
          gateway_iam_role {}
        }
      
        target_configuration {
          mcp {
            lambda {
              lambda_arn = aws_lambda_function.mcp_lambda.arn
      
              tool_schema {
                inline_payload {
                  name        = "placeholder_tool"
                  description = "Placeholder tool (no-op)."
                  input_schema {
                    type        = "object"
                    description = "Example input schema for placeholder tool"
                    property {
                      name        = "string_param"
                      type        = "string"
                      description = "Example string parameter."
                    }
                    property {
                      name        = "int_param"
                      type        = "integer"
                      description = "Example integer parameter."
                    }
                    property {
                      name        = "float_array_param"
                      type        = "array"
                      description = "Example float array parameter."
                      items {
                        type = "number"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime IAM Roles
      ################################################################################
      
      data "aws_iam_policy_document" "bedrock_agentcore_assume_role" {
        statement {
          effect  = "Allow"
          actions = ["sts:AssumeRole"]
          principals {
            type        = "Service"
            identifiers = ["bedrock-agentcore.amazonaws.com"]
          }
        }
      }
      
      resource "aws_iam_role" "agentcore_runtime_execution_role" {
        name        = "${var.app_name}-AgentCoreRuntimeRole"
        description = "Execution role for Bedrock AgentCore Runtime"
      
        assume_role_policy = data.aws_iam_policy_document.bedrock_agentcore_assume_role.json
      }
      
      # https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-permissions.html#runtime-permissions-execution
      resource "aws_iam_role_policy" "agentcore_runtime_execution_role_policy" {
        role   = aws_iam_role.agentcore_runtime_execution_role.id
        name = "${var.app_name}-AgentCoreRuntimeExecutionPolicy"
        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "ECRImageAccess"
              Effect = "Allow"
              Action = [
                "ecr:BatchGetImage",
                "ecr:GetDownloadUrlForLayer",
              ]
              Resource = [
                "arn:aws:ecr:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:repository/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogStreams",
                "logs:CreateLogGroup",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:DescribeLogGroups",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:*",
              ]
            },
            {
              Effect = "Allow"
              Action = [
                "logs:CreateLogStream",
                "logs:PutLogEvents",
              ]
              Resource = [
                "arn:aws:logs:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*",
              ]
            },
            {
              Sid    = "ECRTokenAccess"
              Effect = "Allow"
              Action = [
                "ecr:GetAuthorizationToken",
              ]
              Resource = "*"
            },
            {
              Effect = "Allow"
              Action = [
                "xray:PutTraceSegments",
                "xray:PutTelemetryRecords",
                "xray:GetSamplingRules",
                "xray:GetSamplingTargets",
              ]
              Resource = [
                "*",
              ]
            },
            {
              Effect   = "Allow"
              Resource = "*"
              Action   = "cloudwatch:PutMetricData"
              Condition = {
                StringEquals = {
                  "cloudwatch:namespace" = "bedrock-agentcore"
                }
              }
            },
            {
              Sid    = "GetAgentAccessToken"
              Effect = "Allow"
              Action = [
                "bedrock-agentcore:GetWorkloadAccessToken",
                "bedrock-agentcore:GetWorkloadAccessTokenForJWT",
                "bedrock-agentcore:GetWorkloadAccessTokenForUserId",
              ]
              Resource = [
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default",
                "arn:aws:bedrock-agentcore:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:workload-identity-directory/default/workload-identity/agentName-*",
              ]
            },
            {
              Sid    = "BedrockModelInvocation"
              Effect = "Allow"
              Action = [
                "bedrock:InvokeModel",
                "bedrock:InvokeModelWithResponseStream",
              ]
              Resource = [
                "arn:aws:bedrock:*::foundation-model/*",
                "arn:aws:bedrock:${data.aws_region.current.region}:${data.aws_caller_identity.current.account_id}:*",
              ]
            },
          ]
        })
      }
      
      
      ################################################################################
      # AgentCore Memory
      ################################################################################
      resource "aws_bedrockagentcore_memory" "agentcore_memory" {
        name                  = "testProj_Memory"
        description           = "Memory resource with 30 days event expiry"
        event_expiry_duration = 30
      }
      # Add a built-in strategy from https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/built-in-strategies.html or define a custom one
      # Example of adding semantic memory
      # resource "aws_bedrockagentcore_memory_strategy" "semantic" {
      #  name        = "semantic-strategy"
      #  memory_id   = aws_bedrockagentcore_memory.agentcore_memory.id
      #  type        = "SEMANTIC"
      #  description = "Semantic understanding strategy"
      #  namespaces  = ["default"]
      # }
      
      ################################################################################
      # AgentCore Runtime
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime" "agentcore_runtime" {
        agent_runtime_name = "testProj_Agent"
        role_arn           = aws_iam_role.agentcore_runtime_execution_role.arn
      
        agent_runtime_artifact {
          container_configuration {
            container_uri = "${aws_ecr_repository.agentcore_terraform_runtime.repository_url}:latest"
          }
        }
      
        depends_on = [null_resource.docker_image, aws_bedrockagentcore_memory.agentcore_memory]
      
        network_configuration {
          network_mode = "PUBLIC"
        }
        environment_variables = {
          MEMORY_ID = aws_bedrockagentcore_memory.agentcore_memory.id
          GATEWAY_URL = aws_bedrockagentcore_gateway.agentcore_gateway.gateway_url
          COGNITO_CLIENT_ID     = aws_cognito_user_pool_client.cognito_app_client.id
          COGNITO_CLIENT_SECRET = aws_cognito_user_pool_client.cognito_app_client.client_secret
          COGNITO_TOKEN_URL     = "https://${aws_cognito_user_pool_domain.cognito_domain.domain}.auth.${data.aws_region.current.region}.amazoncognito.com/oauth2/token"
          COGNITO_SCOPE         = "${aws_cognito_resource_server.cognito_resource_server.identifier}/basic"
        }
      }
      
      
      ################################################################################
      # AgentCore Runtime Endpoints
      ################################################################################
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "dev_endpoint" {
        name             = "DEV"
        agent_runtime_id = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
      }
      
      
      resource "aws_bedrockagentcore_agent_runtime_endpoint" "prod_endpoint" {
        name                  = "PROD"
        agent_runtime_id      = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
        agent_runtime_version = var.agent_runtime_version
        depends_on = [aws_bedrockagentcore_agent_runtime_endpoint.dev_endpoint] # Prevents ConflictException
      }
    ''',
    'terraform/main.tf': '''
      terraform {
        required_providers {
          aws = {
            source = "hashicorp/aws"
            version = ">= 6.19"
          }
        }
      
        required_version = ">= 1.2"
      }
      
      output "agentcore_runtime_id" {
        description = "AgentCore Runtime ID"
        value       = aws_bedrockagentcore_agent_runtime.agentcore_runtime.agent_runtime_id
      }
      
      output "mcp_lambda_arn" {
        description = "MCP Lambda Function ARN"
        value       = aws_lambda_function.mcp_lambda.arn
      }
      
      output "ecr_repository_url" {
        description = "ECR Repository URL"
        value       = aws_ecr_repository.agentcore_terraform_runtime.repository_url
      }
    ''',
    'terraform/terraform.tfvars': '''
      # Application Configuration
      app_name = "testProj"
      
      # Runtime Version for PROD endpoint
      # Update this value when you want to promote a new version to production
      # DEV endpoint always uses the latest version automatically
      agent_runtime_version = "1"
    ''',
    'terraform/variables.tf': '''
      # Variables
      variable "app_name" {
        description = "Application name"
        type        = string
      }
      
      variable "agent_runtime_version" {
        description = "Runtime version for PROD endpoint"
        type        = string
        default     = "1"
      }
      
      data "aws_region" "current" { }
      
      data "aws_caller_identity" "current" {}
    ''',
  })
# ---
